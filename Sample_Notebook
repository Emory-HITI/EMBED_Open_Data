{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### This notebook shows examples of how to manipulate the clinical data and metadata. Three tasks will be accomplished:\n",
    "#### 1 : Get the path of all BIRADS-1 and BIRADS-2 screening images\n",
    "#### 2 : Summarize image findings and append to clinical table\n",
    "#### 3 : Get all BIRADS-0 images, the cancer cases and show their ROIs\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 122,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "import cv2\n",
    "import imageio\n",
    "import matplotlib\n",
    "import os\n",
    "import os.path\n",
    "from matplotlib import pyplot as plt\n",
    "from matplotlib.pyplot import figure\n",
    "import matplotlib.patches as patches\n",
    "from PIL import Image\n",
    "import numpy as np\n",
    "import random\n",
    "import ast\n",
    "import gc\n",
    "import time\n",
    "import re\n",
    "import random\n",
    "import pydicom\n",
    "from pydicom import dcmread\n",
    "from pydicom.data import get_testdata_file"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Preparing the datasets, and show datasets size:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "def stats(df): #the function displays dataframe size, countings of unique patients and unique exams\n",
    "    print('Dataframe size: ' + str(df.shape))\n",
    "    try:\n",
    "        print('# patients: ' + str(df.empi_anon.nunique()))\n",
    "    except:\n",
    "        print('# patients: ' + str(df.empi_anon_x.nunique()))\n",
    "    print('# exams: ' + str(df.acc_anon.nunique()))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/tljh/user/lib/python3.7/site-packages/IPython/core/interactiveshell.py:3331: DtypeWarning: Columns (31,34,36,51,52,53,54,56,57,58,59,60,62,64,66,79,81,84,85,87,88,96,114) have mixed types.Specify dtype option on import or set low_memory=False.\n",
      "  exec(code_obj, self.user_global_ns, self.user_ns)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (428971, 21)\n",
      "# patients: 116890\n",
      "# exams: 383379\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "/opt/tljh/user/lib/python3.7/site-packages/IPython/core/interactiveshell.py:3331: DtypeWarning: Columns (74,103,104,113,114,115,116,117,118,128,130,131,132,133,134,136,141,145,146,147) have mixed types.Specify dtype option on import or set low_memory=False.\n",
      "  exec(code_obj, self.user_global_ns, self.user_ns)\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (3383659, 12)\n",
      "# patients: 115931\n",
      "# exams: 365061\n"
     ]
    }
   ],
   "source": [
    "basepath = \"./\" #define the file directory\n",
    "# Load clinical and metadata, filter for fields needed for the tasks we are showcasing in this notebook\n",
    "# df_clinical = pd.read_csv(basepath + \"tables/EMBED_OpenData_clinical.csv\")\n",
    "df_clinical = pd.read_csv(\"magview_all_cohorts_anon_HITI.csv\") ###noteToSelf: change later when get new data\n",
    "\n",
    "df_clinical = df_clinical[['empi_anon','acc_anon','study_date_anon','asses', 'tissueden',\n",
    "                          'desc','side','path_severity','numfind','total_L_find','total_R_find',\n",
    "                          'massshape','massmargin','massdens','calcfind','calcdistri','calcnumber',\n",
    "                          'ETHNICITY_DESC','ETHNIC_GROUP_DESC','age_at_study','ETHNIC_GROUP_DESC']]\n",
    "stats(df_clinical)\n",
    "\n",
    "#df_metadata = pd.read_csv(basepath + \"tables/EMBED_OpenData_metadata.csv\")\n",
    "df_metadata = pd.read_csv(\"metadata_all_cohort_with_ROI_HITI.csv\") ###noteToSelf: change later when get new data\n",
    "df_metadata = df_metadata[['anon_dicom_path','empi_anon','acc_anon','study_date_anon',\n",
    "                            'StudyDescription','SeriesDescription','FinalImageType',\n",
    "                            'ImageLateralityFinal','ViewPosition','spot_mag','ROI_coords','num_roi']]\n",
    "\n",
    "stats(df_metadata)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true,
    "tags": []
   },
   "source": [
    "### Task 1: Get the dicom file path of all BIRADS-1 and BIRADS-2 screening 2D images"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (311129, 21)\n",
      "# patients: 103704\n",
      "# exams: 295885\n"
     ]
    }
   ],
   "source": [
    "#filter for screening exams only\n",
    "df_clinical_screen = df_clinical.loc[df_clinical.desc.str.contains('screen',case=False)]\n",
    "stats(df_clinical_screen)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (254334, 21)\n",
      "# patients: 89458\n",
      "# exams: 251403\n"
     ]
    }
   ],
   "source": [
    "# Filtering clinical data for birads 1 (negative) and 2 (benign) assessments. \n",
    "df_clinical_br12 = df_clinical_screen[(df_clinical_screen.asses == \"N\") | (df_clinical_screen.asses == \"B\")]\n",
    "# The column 'asses' indicates the BIRADS assessment of the exam. 'N' indicates negative/BIRADS-1, 'B' indicates benign/BIRADS-2\n",
    "stats(df_clinical_br12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (2251599, 32)\n",
      "# patients: 87937\n",
      "# exams: 238513\n"
     ]
    }
   ],
   "source": [
    "# Merging metadata and clinical data on exam ID (acc_anon). This will link the clinical data to the file list from metadata\n",
    "df_merge12 = pd.merge(df_metadata, df_clinical_br12, on=['acc_anon'])\n",
    "\n",
    "# The 'side' column in the clinical data represents the laterality of the finding in that row, and can be L (left), R (right), B (bilateral), or NaN (when there is no finding).\n",
    "#Therefore when merging clinical and metadata, we must first match by exam ID and then match the laterality of the clinical finding (side) to the laterality of the image (ImageLateralityFinal)\n",
    "# Side \"B\" and \"NaN\" can be matched to ImageLateralityFinal both \"L\" and \"R\"\n",
    "df_merge12 = df_merge12.loc[\n",
    "    (df_merge12.side == df_merge12.ImageLateralityFinal) \n",
    "    | (df_merge12.side == 'B') | (pd.isna(df_merge12.side))] \n",
    "\n",
    "stats(df_merge12)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (1136224, 32)\n",
      "# patients: 87927\n",
      "# exams: 238458\n"
     ]
    }
   ],
   "source": [
    "#filter for 2D images only\n",
    "df_merge12_2d = df_merge12.loc[df_merge12.FinalImageType=='2D']\n",
    "stats(df_merge12_2d)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 32,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1130172\n"
     ]
    }
   ],
   "source": [
    "#generate list of all files dicom paths\n",
    "br12_img_list = list(df_merge12_2d.anon_dicom_path.unique())\n",
    "print(len(br12_img_list))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Task 2: Summarize image findings and append to clinical table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 51,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (59510, 21)\n",
      "# patients: 41778\n",
      "# exams: 48612\n"
     ]
    }
   ],
   "source": [
    "# Filtering clinical for birads 0\n",
    "df_clinical_br0 = df_clinical.loc[df_clinical.asses == \"A\"]\n",
    "stats(df_clinical_br0)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 66,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Adding columns \"mass\", \"asymmetry\", \"arch_distortion\" and \"calc\" for image findings, coded 1 yes; 0 no such finding\n",
    "# showing example for BIRADS-1 cases\n",
    "df_findings_count = df_clinical_br0.copy()\n",
    "\n",
    "# Generating lists for four findings: mass, asymmetry, architectural distortion and calcification respectively, \n",
    "# coded 1 yes, 0 no such finding presented in current datapoint;\n",
    "# (lists are generated first instead of directly change in dataframe in order to avoid dataframe rewriting errors)\n",
    "df_findings_count = df_findings_count.reset_index(drop=True)\n",
    "mass_list = [0]*df_findings_count.shape[0]\n",
    "asymmetry_list = [0]*df_findings_count.shape[0]\n",
    "arch_destortion_list = [0]*df_findings_count.shape[0]\n",
    "calc_list = [0]*df_findings_count.shape[0]\n",
    "\n",
    "# Architectural Distortion:  'massshape' in ['Q', 'A']\n",
    "# Asymmetry: 'massshape' in ['T', 'B', 'S', 'F', 'V']\n",
    "# Mass: 'massshape' in ['G', 'R', 'O', 'X', 'N', 'Y', 'D', 'L']\n",
    "#       or 'massmargin' in ['D', 'U', 'M', 'I', 'S']\n",
    "#       or 'massdens' in ['+', '-', '=']\n",
    "# Calcification: if any of the values in \"calcdistri\", \"calcfind\" and \"calcnumber\" is not nan or 0, then calcification was presented\n",
    "\n",
    "for ind, row in df_findings_count.iterrows():\n",
    "    if (row['massshape'] in ['G', 'R', 'O', 'X', 'N', 'Y', 'D', 'L']) or (row['massmargin'] in ['D', 'U', 'M', 'I', 'S']) or (row['massdens'] in ['+', '-', '=']):\n",
    "        mass_list[ind] = 1\n",
    "        \n",
    "    if row['massshape'] in ['T', 'B', 'S', 'F', 'V']:\n",
    "        asymmetry_list[ind] = 1\n",
    "\n",
    "    if row['massshape']in ['Q', 'A']:\n",
    "        arch_destortion_list[ind] = 1\n",
    "        \n",
    "    if (row['calcdistri'] is not np.nan) or (row['calcfind'] is not np.nan) or (row['calcnumber'] != 0):\n",
    "        calc_list[ind] = 1        \n",
    "\n",
    "# Append the final image findings columns to the dataframe        \n",
    "df_findings_count['mass'] = mass_list\n",
    "df_findings_count['asymmetry'] = asymmetry_list\n",
    "df_findings_count['arch_distortion'] = arch_destortion_list\n",
    "df_findings_count['calc'] = calc_list"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Mass findings count\n",
      "0    51128\n",
      "1     8382\n",
      "Name: mass, dtype: int64 \n",
      "\n",
      "Asymmetry findings count\n",
      "1    29978\n",
      "0    29532\n",
      "Name: asymmetry, dtype: int64 \n",
      "\n",
      "Architectural distortion findings count\n",
      "0    56460\n",
      "1     3050\n",
      "Name: arch_distortion, dtype: int64 \n",
      "\n",
      "Calcification findings count\n",
      "0    49467\n",
      "1    10043\n",
      "Name: calc, dtype: int64\n"
     ]
    }
   ],
   "source": [
    "print('Mass findings count')\n",
    "print(df_findings_count.mass.value_counts(),'\\n')\n",
    "print('Asymmetry findings count')\n",
    "print(df_findings_count.asymmetry.value_counts(),'\\n')\n",
    "print('Architectural distortion findings count')\n",
    "print(df_findings_count.arch_distortion.value_counts(),'\\n')\n",
    "print('Calcification findings count')\n",
    "print(df_findings_count.calc.value_counts())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_clinical_br0_addFindings = df_findings_count.copy()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Task 3: Get all BIRADS-0 images, the cancer cases where there're ROIs, export as table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 84,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (603553, 36)\n",
      "# patients: 40757\n",
      "# exams: 46953\n",
      "Dataframe size: (313482, 36)\n",
      "# patients: 40717\n",
      "# exams: 46907\n"
     ]
    }
   ],
   "source": [
    "# Merging metadata and clinical on exam ID\n",
    "df_merge0 = pd.merge(df_metadata, df_clinical_br0_addFindings, on=['acc_anon'])\n",
    "stats(df_merge0)\n",
    "\n",
    "# The 'side' column in the clinical data represents the laterality of the finding in that row, and can be L (left), R (right), B (bilateral), or NaN (when there is no finding).\n",
    "#Therefore when merging clinical and metadata, we must first match by exam ID and then match the laterality of the clinical finding (side) to the laterality of the image (ImageLateralityFinal)\n",
    "# Side \"B\" and \"NaN\" can be matched to ImageLateralityFinal both \"L\" and \"R\"\n",
    "df_merge0 = df_merge0.loc[\n",
    "    (df_merge0.side == df_merge0.ImageLateralityFinal) \n",
    "    | (df_merge0.side == 'B') | (pd.isna(df_merge0.side))] \n",
    "\n",
    "stats(df_merge0) #note the significant drop in number of rows after forcing the above laterality match while maintaining the number of patients and exams. \n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 103,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (159374, 36)\n",
      "# patients: 40714\n",
      "# exams: 46898\n"
     ]
    }
   ],
   "source": [
    "#filter for 2D images only\n",
    "df_merge0_2d = df_merge0.loc[df_merge0.FinalImageType=='2D']\n",
    "df_merge0_2d = df_merge0_2d.drop_duplicates()\n",
    "stats(df_merge0_2d)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 104,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Dataframe size: (4742, 36)\n",
      "# patients: 1480\n",
      "# exams: 1507\n"
     ]
    }
   ],
   "source": [
    "# Filtering cancer cases. When \"path_severity\" is 0 (invasive breast cancer) or 1 (in situ cancer), indicating biopsy results being cancer. 2-5 means benign and NaN means never biopsied.\n",
    "df_cancer = df_merge0_2d[df_merge0_2d['path_severity'].isin([0,1])]\n",
    "\n",
    "stats(df_cancer)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 94,
   "metadata": {},
   "outputs": [],
   "source": [
    "def separate_roi(df): #the function that separate multiple ROIs individually into different rows\n",
    "    df_list = []\n",
    "    for ind, row in df.iterrows():\n",
    "        path = row['anon_dicom_path']\n",
    "        roi_num = [int(s) for s in re.findall(r'\\b\\d+\\b', row['ROI_coords'])]\n",
    "        if len(roi_num)==4:\n",
    "            df_list.append([path, row['ROI_coords'], row['ROI_coords']])\n",
    "        else:\n",
    "            count = 0\n",
    "            roi = []\n",
    "            for i in roi_num:\n",
    "                count += 1\n",
    "                roi.append(i)\n",
    "                if count%4 == 0:\n",
    "                    df_list.append([path, row['ROI_coords'], \"((\"+str(roi[0])+\", \"+str(roi[1])+\", \"+str(roi[2])+\", \"+str(roi[3])+\"),)\"])\n",
    "                    roi = []\n",
    "    df_roi_sep = pd.DataFrame(df_list)\n",
    "    df_roi_sep.columns = ['anon_dicom_path','ROI_coords','ROI_separated']\n",
    "    df_cp = df.copy()\n",
    "    df_cp = df_cp.merge(df_roi_sep, how='left', on=['anon_dicom_path','ROI_coords'])\n",
    "    return df_cp"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# To export ROIs, filter the ones with ROIs\n",
    "df_cancer_ROI = df_cancer.loc[df_cancer.ROI_coords!='()']\n",
    "# Separate multiple ROIs into individual rows\n",
    "df_cancer_ROI = separate_roi(df_cancer_ROI)\n",
    "\n",
    "# Export to csv\n",
    "df_cancer_ROI.to_csv(\"BR0CancerROIs.csv\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Showing an example ROI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 109,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "0                              ((1365, 272, 1610, 508),)\n",
       "1                              ((1951, 347, 2244, 626),)\n",
       "2                             ((2300, 776, 2689, 1149),)\n",
       "3                             ((2053, 809, 2295, 1054),)\n",
       "4                              ((1514, 704, 1681, 976),)\n",
       "                              ...                       \n",
       "1762                          ((2064, 847, 2633, 1864),)\n",
       "1763     ((1618, 57, 1908, 390), (1634, 107, 1915, 414))\n",
       "1764     ((1618, 57, 1908, 390), (1634, 107, 1915, 414))\n",
       "1765    ((1935, 450, 2231, 784), (1968, 447, 2205, 740))\n",
       "1766    ((1935, 450, 2231, 784), (1968, 447, 2205, 740))\n",
       "Name: ROI_coords, Length: 1767, dtype: object"
      ]
     },
     "execution_count": 109,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "df_cancer_ROI.ROI_coords"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 110,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'((1951, 347, 2244, 626),)'"
      ]
     },
     "execution_count": 110,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sample_file_name = df_cancer_ROI.anon_dicom_path[1]\n",
    "sample_file_ROI = df_cancer_ROI.ROI_coords[1]\n",
    "sample_file_ROI"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 111,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "data": {
      "text/plain": [
       "'/mnt/NAS2/mammo/anon_dicom/cohort_1/18939478/1.2.849.113974.3.61.1.52711867.20160329.1091560/1.2.848.113681.2230564627.935.3636186671.120.1/1.2.826.0.1.3680043.8.498.12257306895206838611171994903114978464.dcm'"
      ]
     },
     "execution_count": 111,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "sample_file_name"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 132,
   "metadata": {},
   "outputs": [
    {
     "ename": "RuntimeError",
     "evalue": "The following handlers are available to decode the pixel data however they are missing required dependencies: GDCM (req. GDCM), pylibjpeg (req. )",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mRuntimeError\u001b[0m                              Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-132-ebb160e8d914>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0msample_file_name\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;34m'1.2.826.0.1.3680043.8.498.12257306895206838611171994903114978464.dcm'\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0mds\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0mpydicom\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdcmread\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0msample_file_name\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 6\u001b[0;31m \u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mimshow\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mds\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mpixel_array\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mcmap\u001b[0m\u001b[0;34m=\u001b[0m\u001b[0mplt\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mcm\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbone\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m",
      "\u001b[0;32m~/.local/lib/python3.7/site-packages/pydicom/dataset.py\u001b[0m in \u001b[0;36mpixel_array\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1885\u001b[0m             \u001b[0;34m:\u001b[0m\u001b[0;32mclass\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;31m`\u001b[0m\u001b[0mnumpy\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mndarray\u001b[0m\u001b[0;31m`\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1886\u001b[0m         \"\"\"\n\u001b[0;32m-> 1887\u001b[0;31m         \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconvert_pixel_data\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1888\u001b[0m         \u001b[0;32mreturn\u001b[0m \u001b[0mcast\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m\"numpy.ndarray\"\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_pixel_array\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1889\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/.local/lib/python3.7/site-packages/pydicom/dataset.py\u001b[0m in \u001b[0;36mconvert_pixel_data\u001b[0;34m(self, handler_name)\u001b[0m\n\u001b[1;32m   1442\u001b[0m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_convert_pixel_data_using_handler\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mhandler_name\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1443\u001b[0m         \u001b[0;32melse\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1444\u001b[0;31m             \u001b[0mself\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0m_convert_pixel_data_without_handler\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1445\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1446\u001b[0m     \u001b[0;32mdef\u001b[0m \u001b[0m_convert_pixel_data_using_handler\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mself\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mname\u001b[0m\u001b[0;34m:\u001b[0m \u001b[0mstr\u001b[0m\u001b[0;34m)\u001b[0m \u001b[0;34m->\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m:\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;32m~/.local/lib/python3.7/site-packages/pydicom/dataset.py\u001b[0m in \u001b[0;36m_convert_pixel_data_without_handler\u001b[0;34m(self)\u001b[0m\n\u001b[1;32m   1529\u001b[0m                 )\n\u001b[1;32m   1530\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m-> 1531\u001b[0;31m             \u001b[0;32mraise\u001b[0m \u001b[0mRuntimeError\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mmsg\u001b[0m \u001b[0;34m+\u001b[0m \u001b[0;34m', '\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mjoin\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0mpkg_msg\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m   1532\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m   1533\u001b[0m         \u001b[0mlast_exception\u001b[0m \u001b[0;34m=\u001b[0m \u001b[0;32mNone\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mRuntimeError\u001b[0m: The following handlers are available to decode the pixel data however they are missing required dependencies: GDCM (req. GDCM), pylibjpeg (req. )"
     ]
    }
   ],
   "source": [
    "# For sample instance, the dicom file was stored in current folder for convenience\n",
    "import pylibjpeg\n",
    "\n",
    "sample_file_name = '1.2.826.0.1.3680043.8.498.12257306895206838611171994903114978464.dcm'\n",
    "ds = pydicom.dcmread(sample_file_name)\n",
    "plt.imshow(ds.pixel_array, cmap=plt.cm.bone) "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<br><br><br><br>End of notebook <br><br><br><br>"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
